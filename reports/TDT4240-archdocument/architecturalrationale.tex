\section{Architectural rationale}

\subsection{Modifiability}\label{architectural-modifiability}
The primary quality attribute of our software architecture, is that it should be modifiable -- that is, it should be easy to add or change functionality. We've achieved this through several architecture and technology choices.

Our application implements a \textbf{client--server} architecture, where all of the game logic is on the server and the client is a relatively simple view. This architectural choice entails that adding support for multiple platforms should not require changes to the game itself; we could add an arbitrary number of different client applications that all use the same networked API. This ties in to our choice of an \textbf{MVC} architecture, where the models and controllers are on the server and the views are on the clients. Decoupling the game logic from platform-specific representation makes it easy to add other clients. This is made even simpler through our use of the libGDX framework~\cite{libgdx}, which allows us to package our client application for Windows, Mac, Linux, Android, iOS, BlackBerry or HTML5 using the same codebase.

Furthermore, our server application does not communicate directly with its data store, but does so through an \textbf{object-relational mapping (ORM)}. This means that we only deal with objects native to the programming language of our server application, and the ORM converts these objects to the form required by our database, as well as handling reading and writing to the database. By using an ORM, we can easily change from one database management system (DBMS) to another, given that they are both supported by the ORM in question. Not having a strong dependence on a single DBMS, means that it is easier to switch to another form of hosting where another DBMS may be preferred, or to switch to another DBMS if we find that this is advantageous to, say, performance. A nice side-effect of using an ORM, is that many developers find it to be more readable and understandable when compared to writing plain SQL or other database-specific languages in the application code.

\subsection{Networking, availability and performance}
Because our product is a multiplayer game, where each player uses his own device, we have two options when it comes to communication: Using a game server, as we have decided to do, or using peer-to-peer connectivity. In the latter case, Bluetooth or a similar short-range, radio-based protocol is the only feasible solution as peer-to-peer connectivity over the Internet is fairly difficult, especially on mobile devices, due to security settings on the devices. Such a solution implies that the players need to be physically close to each other, which seems an unwanted requirement, hence the game server.

Using a client--server architecture, as we do, has the advantages mentioned in the section on modifiability (\ref{architectural-modifiability}) when it comes to decoupling game logic and user interfaces. However, it also has its own set of challenges as discussed in section~\ref{availability-tactics}.

As a side note, because our game will run on Android devices with varying technical specifications, there is an element of uncertainty when it comes to device performance. As our game is turn-based and very simple, performance should not be a problem on any modern device; however, if this were to be an issue, running the business logic on the server would make the performance depend (almost) only on the speed of the network connection, resulting in a more predictable user experience and fairly low battery usage.